@startuml flow1_import_repos_sequence
!theme plain

participant "UI\nFrontend" as UI
participant "API\nLayer" as API
participant "GitHub\nAPI" as GH
participant "Database\n(MongoDB)" as DB
participant "Celery\nWorker" as CELERY
participant "Git\nRepository" as GIT
participant "CI Provider\n(GitHub Actions)" as CI

autonumber

== PHASE 1: SEARCH REPOSITORIES ==

UI -> API: POST /repos/search?q="pytorch"
activate API
API -> API: Validate query
API -> GH: GET /search/repositories?q=pytorch
activate GH
GH --> API: Search results + metadata
deactivate GH

API -> GH: GET /user/repos (private repos)
activate GH
GH --> API: User's private repos
deactivate GH

API --> UI: RepoSuggestion[] {private_matches, public_matches}
deactivate API

UI -> UI: Display search results
UI -> UI: User selects 2 repos

== PHASE 2: CONFIGURE & IMPORT ==

UI -> API: POST /repos/import/bulk
activate API
note right of API
  payload = [
    {
      full_name: "pytorch/pytorch",
      installation_id: "123456",
      test_frameworks: ["pytest"],
      source_languages: ["python"],
      ci_provider: "github_actions",
      max_builds: 100,
      since_days: 180
    }
  ]
end note

API -> GH: GET /repos/pytorch/pytorch
activate GH
GH --> API: Repo metadata {id, default_branch, language}
deactivate GH

API -> DB: Create/Update RawRepository
activate DB
DB --> API: RawRepository created
deactivate DB

API -> DB: Create ModelRepoConfig {status: QUEUED}
activate DB
DB --> API: ModelRepoConfig created
deactivate DB

API -> CELERY: import_repo.delay(repo_id, full_name, ...)
activate CELERY
note right of CELERY
  Queue task to Celery
  Returns immediately
end note

API --> UI: RepoResponse[] {status: QUEUED}
deactivate API

UI -> UI: Show import confirmation
UI -> UI: Subscribe WebSocket

== PHASE 3: ASYNC IMPORT CHAIN ==

note over CELERY
  Celery chain executes:
  import_repo → clone_repo → fetch_and_save_builds → dispatch_processing
end note

CELERY -> DB: Update status = IMPORTING
activate DB
DB --> CELERY: OK
deactivate DB

CELERY -> GIT: Check repo_path exists
activate GIT
GIT --> CELERY: NO (new repo)
deactivate GIT

CELERY -> GH: Get installation token
activate GH
GH --> CELERY: token = "v1.xyz..."
deactivate GH

CELERY -> GIT: git clone --bare https://x-access-token:token@github.com/pytorch/pytorch.git
activate GIT
note right of GIT
  Clone repository to
  REPOS_DIR/repo_id/
end note
GIT --> CELERY: Repository cloned (5-30 min)
deactivate GIT

CELERY -> UI: Publish WebSocket: {status: "cloned"}

== PHASE 4: FETCH BUILDS FROM CI ==

CELERY -> CI: ci_instance.fetch_builds(
activate CI
note right of CI
  Parameters:
  - full_name: "pytorch/pytorch"
  - since: (datetime)
  - limit: 100
  - exclude_bots: true
  - only_with_logs: true
end note

CI --> CELERY: Build[] {build_id, commit_sha, status, conclusion}
deactivate CI

CELERY -> DB: for each build:
activate DB
note right of DB
  1. Check if RawBuildRun exists
  2. If not: Create RawBuildRun
  3. Create ModelTrainingBuild {status: PENDING}
  
  Saves ~100 builds
end note
DB --> CELERY: Builds saved
deactivate DB

CELERY -> DB: Update ModelRepoConfig {build_count: 100}
activate DB
DB --> CELERY: OK
deactivate DB

CELERY -> UI: Publish WebSocket: {status: "found_builds", count: 100}

== PHASE 5: DISPATCH FEATURE EXTRACTION ==

CELERY -> DB: Find all ModelTrainingBuilds with status=PENDING
activate DB
DB --> CELERY: build_ids list
deactivate DB

CELERY -> CELERY: for batch in build_ids (batch_size=50):
note right of CELERY
  Batch 1: [build_1, build_2, ..., build_50]
  Batch 2: [build_51, ..., build_100]
end note

CELERY -> CELERY: group([
  process_workflow_run.s(repo_id, build_1),
  process_workflow_run.s(repo_id, build_2),
  ...
])
note right of CELERY
  Create group of 50 tasks
  apply_async() to queue
end note

CELERY -> DB: Update status = IMPORTED
activate DB
DB --> CELERY: OK
deactivate DB

CELERY -> UI: Publish WebSocket: {status: "import_completed"}

== PHASE 6: FEATURE EXTRACTION (Per Build) ==

note over CELERY
  For each build (can run in parallel)
end note

CELERY -> DB: process_workflow_run(repo_id, build_id)
activate DB
note right of DB
  Fetch:
  - RawRepository
  - RawBuildRun
  - ModelRepoConfig
end note
DB --> CELERY: OK
deactivate DB

CELERY -> UI: Publish WebSocket: {status: "extracting", build_id}

CELERY -> GIT: build_hamilton_inputs()
activate GIT
note right of GIT
  From repo_path:
  - Get git history
  - Create git worktree
  - Extract commit info
end note
GIT --> CELERY: HamiltonInputs
deactivate GIT

CELERY -> CELERY: HamiltonPipeline.run()
activate CELERY
note right of CELERY
  Execute Hamilton DAG:
  ├─ build_features
  ├─ git_features
  ├─ github_features
  ├─ repo_features
  └─ log_features
  
  Returns: features = {
    "tr_build_duration": 120,
    "tr_test_count": 250,
    ...
  }
end note

CELERY -> DB: Update ModelTrainingBuild
activate DB
note right of DB
  features = {...}
  extraction_status = COMPLETED
  (or PARTIAL/FAILED)
end note
DB --> CELERY: OK
deactivate DB

CELERY -> UI: Publish WebSocket: {status: "completed", build_id}
deactivate CELERY

UI -> UI: Receive update
UI -> UI: Mark build as completed
UI -> UI: Display extracted features

== UI DISPLAY ==

UI -> DB: GET /repos/{repo_id}/builds
activate DB
DB --> UI: ModelTrainingBuild[] with features
deactivate DB

UI -> UI: Show build metrics:
note right of UI
  - Build duration
  - Test count
  - Failure rate
  - Git activity
  - PR metrics
  - etc.
end note

@enduml
